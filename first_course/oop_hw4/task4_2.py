"""
4.2. Выберите любую иерархию, в родительском классе сделайте метод, условно, foo(), а в обоих дочерних классах
переопределите его. В каждой из трёх реализаций foo() выводите в консоль что-то оригинальное (например, название
класса), чтобы можно было различить, для какого класса foo() вызывается.
"""
import random


class Tea:
    def foo(self):
        return "Tea"


# Дочерний класс для класса "чай", Черный чай
class BlackTea(Tea):
    def foo(self):
        return f'BlackTea {str(self)}'


class Puer(Tea):
    def foo(self):
        return f'Puer     {str(self)}'


arr = []
for i in range(500):
    if random.randint(0, 1) == 0:
        arr.append(BlackTea())
    else:
        arr.append(Puer())
random.shuffle(arr)  # список из 500 объектов, где будут случайно перемешаны 500 объектов двух дочерних классов

m = set()
print(f'Номер | Класс | Адрес объекта в памяти')
for j in range(500):
    tea_object = arr[j].foo()
    m.add(tea_object)
    print(f'{j + 1}     {tea_object}')

print(
    f'{len(m)} - количество элементов в множестве, в которое я добавлял выводы метода foo для каждого объекта.'
    f' Т.к я возвращал не только название класса, но и адрес объекта в памяти, '
    f'то можно заметить, что все экземпляры класса уникальны и находятся в различных областях памяти')

"""
Выыод:
Мой код показывает пример использования полиморфизма, который  позволяет объектам различных классов
вызывать методы с одинаковыми именами, но разными реализациями.
Каждый вызов foo() возвращает строку, в которой указаны название класса и  уникальный адрес объекта в памяти.
"""
